Socket is a interface between the application layer and transport layer.
Socket are endpoints for communication between programs/processes in our computers connected through networks.
a socket is identified as ip address +  port number
in server-client setting both devices have their respect sockets.
theres a stream-socket(tcp) and datagram-socket(udp)
in java sockets are implemented as objects
### 1️⃣ `socket.getInputStream()` and `socket.getOutputStream()`

* **`getInputStream()`** → reads **bytes coming from the other side**.
* **`getOutputStream()`** → writes **bytes to the other side**.
* **Calling `getInputStream()` or `getOutputStream()` alone does not block** — it just gives you a stream object.

So **the order of these calls themselves does not cause deadlock**.

### 2️⃣ Where the deadlock really happens

* Deadlock happens **not at `getInputStream()`**, but at the **construction of `ObjectInputStream` and `ObjectOutputStream`**:

```java
sOutput = new ObjectOutputStream(socket.getOutputStream());
sInput  = new ObjectInputStream(socket.getInputStream());
```

* `ObjectOutputStream` writes a **stream header** immediately.
* `ObjectInputStream` **blocks** until it reads the header.
* If both sides try `new ObjectInputStream(socket.getInputStream())` first → **both block**, because no header is sent yet.

### ✅ Key takeaway

* **`socket.getInputStream()` or `socket.getOutputStream()`**: just returns the raw stream, **does not block**.
* **`new ObjectInputStream()` or `new ObjectOutputStream()`**: this is where **blocking and potential deadlock** happen.
* The “order rule” applies to **Object streams**, not the raw socket streams themselves.

So in short: **it’s not the order of `getInputStream()` vs `getOutputStream()` that causes deadlock** — it’s **the order of creating Object streams on top of them**.

---getOutputStream() gives you a raw byte stream to send data from this program to the other side:
OutputStream os = socket.getOutputStream();
os.write(65); // sends a single byte 'A'

---new ObjectOutputStream(...)

ObjectOutputStream is a wrapper around a byte stream.

It converts Java objects into bytes automatically (serialization).-->class type info is also included in these bytes(serilizable bytes)
On the other side, ObjectInputStream can reconstruct the object from the bytes.
send any serializable Java object(if a custom object  is not serializable java shows nonserilizable exception), not just strings
The client sends a ChatMessage object via ObjectOutputStream.

readObject() reads the serialized bytes from the socket.


new ObjectOutputStream(socket.getOutputStream())
— Writes a stream header bytes to that output stream as part of its constructor. Those bytes sit in the TCP send buffer until flushed or the buffer is full, but usually flush() is used to push them immediately onto the network.

new ObjectInputStream(socket.getInputStream())
— The constructor of ObjectInputStream blocks while it waits to read the stream header from the peer. It will not return until it reads a valid header.

Deadlock scenario (what you must avoid)

If both sides do new ObjectInputStream(...) first, each blocks waiting for the other to send the header. Nobody ever writes the header → deadlock.

If one side does new ObjectInputStream(...) and the other does new ObjectOutputStream(...) but the output side never flushes the header, the input side can still block until data is sent.

Why flush() matters

ObjectOutputStream writes header bytes on construction, but those bytes may remain in Java’s buffered output stream or socket buffers until flushed. Calling sOutput.flush() forces those header bytes to be sent immediately across the socket so the peer’s ObjectInputStream can read them and finish construction.
| Client Order   | Server Order   | Flush?     | Works?     | Why                       |
| -------------- | -------------- | ---------- | ---------- | ------------------------- |
| Output → Input | Output → Input | ✅ Optional | ✅ Yes      | Both send headers quickly |
| Output → Input | Input → Output | Irrelevant | ✅ Yes      | One sends, other reads    |
| Input → Output | Output → Input | Irrelevant | ✅ Yes      | One sends, other reads    |
| Input → Output | Input → Output | Irrelevant | ❌ Deadlock | Both wait to read         |

if a query returns data like select or insert with returning then use-->executeQuery()
if a query doesn't return data like insert update delete use -->executeUpdate();